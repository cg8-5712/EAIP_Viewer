# EAIP Viewer 架构设计文档

## 目录
- [架构概览](#架构概览)
- [技术选型分析](#技术选型分析)
- [分层架构设计](#分层架构设计)
- [核心模块设计](#核心模块设计)
- [数据流设计](#数据流设计)
- [安全架构](#安全架构)
- [性能优化策略](#性能优化策略)
- [可扩展性设计](#可扩展性设计)

---

## 架构概览

### 整体架构图

```
┌────────────────────────────────────────────────────────────┐
│                      用户界面层 (UI Layer)                   │
│  ┌──────────────────┐         ┌──────────────────────────┐ │
│  │  QML UI 层        │         │  Python Widgets 层        │ │
│  │  - 登录界面       │         │  - 航图查看器             │ │
│  │  - 机场列表       │         │  - 标注工具               │ │
│  │  - 搜索页面       │         │  - 水印叠加层             │ │
│  │  - 设置页面       │         │                          │ │
│  └──────────────────┘         └──────────────────────────┘ │
└────────────────────────────────────────────────────────────┘
                          │ Signals & Slots
┌────────────────────────────────────────────────────────────┐
│                   控制器层 (Controller Layer)                │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐  │
│  │ AuthController│  │AirportModel  │  │UpdateController │  │
│  │ 用户认证控制  │  │机场列表模型  │  │OTA 更新控制      │  │
│  └──────────────┘  └──────────────┘  └──────────────────┘  │
│  ┌──────────────┐  ┌──────────────┐                        │
│  │ChartProvider │  │SearchController                       │
│  │航图提供器    │  │搜索控制器    │                        │
│  └──────────────┘  └──────────────┘                        │
└────────────────────────────────────────────────────────────┘
                          │ Business Logic
┌────────────────────────────────────────────────────────────┐
│                  业务逻辑层 (Service Layer)                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐  │
│  │ AuthService  │  │EncryptService│  │UpdateService     │  │
│  │ 认证服务     │  │加密解密服务  │  │数据更新服务      │  │
│  └──────────────┘  └──────────────┘  └──────────────────┘  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐  │
│  │PDFRenderer   │  │SearchEngine  │  │WatermarkService  │  │
│  │PDF 渲染引擎  │  │搜索引擎      │  │水印服务          │  │
│  └──────────────┘  └──────────────┘  └──────────────────┘  │
└────────────────────────────────────────────────────────────┘
                          │ Data Access
┌────────────────────────────────────────────────────────────┐
│                   数据访问层 (Data Layer)                    │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐  │
│  │SQLAlchemy ORM│  │File System   │  │Network Client    │  │
│  │数据库 ORM    │  │文件系统管理  │  │网络请求客户端    │  │
│  └──────────────┘  └──────────────┘  └──────────────────┘  │
└────────────────────────────────────────────────────────────┘
                          │ Storage
┌────────────────────────────────────────────────────────────┐
│                   存储层 (Storage Layer)                     │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐  │
│  │SQLite Database│ │Encrypted Files│ │Cache Storage     │  │
│  │用户/航图数据 │  │加密航图文件  │  │缓存数据          │  │
│  └──────────────┘  └──────────────┘  └──────────────────┘  │
└────────────────────────────────────────────────────────────┘
```

### 架构特点

#### 1. 混合 UI 架构
- **QML 层**: 处理通用界面（列表、搜索、设置）
  - 优势: 声明式开发、动画流畅、开发效率高
  - 适用: 简单交互、数据展示、导航
- **Widgets 层**: 处理复杂业务（航图查看、标注）
  - 优势: 功能强大、精细控制、安全性高
  - 适用: 图形渲染、自定义绘制、底层 API 调用

#### 2. 分层解耦
- UI 层只负责展示和用户交互
- 控制器层负责 UI 与业务逻辑的桥接
- 服务层包含纯粹的业务逻辑（可独立测试）
- 数据层负责数据持久化和访问

#### 3. 安全优先设计
- 文件加密存储
- 用户密码哈希
- 水印追溯机制
- 防截图保护

---

## 技术选型分析

### PyQt6 + QML vs 其他方案

| 技术方案 | 优势 | 劣势 | 适用场景 | 本项目是否采用 |
|---------|------|------|---------|--------------|
| **PyQt6 + QML** | ✅ 现代化 UI<br>✅ 高性能渲染<br>✅ 跨平台一致性<br>✅ 安全功能完善 | ❌ 学习曲线陡峭<br>❌ 打包体积较大 | 需要现代 UI 和安全保护 | ✅ **采用** |
| **PyQt6 纯 Widgets** | ✅ 功能强大<br>✅ 文档丰富<br>✅ 社区成熟 | ❌ UI 过时<br>❌ 开发效率低<br>❌ 动画效果差 | 传统企业应用 | ❌ 仅用于航图查看器 |
| **Electron + React** | ✅ Web 技术栈<br>✅ 生态丰富<br>✅ 开发速度快 | ❌ 安全性差<br>❌ 内存占用高<br>❌ 无法防截图 | Web 应用桌面化 | ❌ 不满足安全需求 |
| **Tauri + Vue** | ✅ 轻量<br>✅ 安全性较好 | ❌ 生态不成熟<br>❌ Python 集成差 | 轻量级桌面应用 | ❌ Python 生态依赖 |
| **Tkinter** | ✅ Python 内置<br>✅ 轻量 | ❌ UI 丑陋<br>❌ 功能受限 | 简单工具脚本 | ❌ 无法满足需求 |

### 选型理由

#### 为什么选择 PyQt6 + QML？

**1. 安全性需求**
- ✅ 支持真正的防截图（Windows SetWindowDisplayAffinity）
- ✅ 可以精细控制文件访问和加密
- ✅ 水印可以在 C++ 层实现，不易绕过
- ❌ Web 技术（Electron/Tauri）无法实现真正的防截图

**2. 性能需求**
- ✅ QML 使用 GPU 加速渲染，动画流畅
- ✅ PyMuPDF 配合 Qt 可高效渲染 PDF
- ✅ 内存占用合理（80-150 MB）
- ❌ Electron 内存占用高（200+ MB）

**3. 开发效率**
- ✅ QML 声明式开发，UI 迭代快
- ✅ Python 业务逻辑开发效率高
- ✅ UI 与逻辑分离，便于团队协作

**4. 跨平台一致性**
- ✅ Qt 在 Windows/macOS/Linux 表现一致
- ✅ 无需针对不同平台重写 UI
- ✅ 打包工具成熟（PyInstaller）

---

## 分层架构设计

### 1. UI 层（用户界面层）

#### QML UI 组件

**职责**:
- 用户交互界面
- 数据展示
- 导航和路由
- 动画效果

**主要组件**:
```
qml/
├── main.qml                  # 主窗口 + 导航框架
├── pages/
│   ├── LoginPage.qml         # 登录/注册页
│   ├── AirportListPage.qml   # 机场列表页
│   ├── ChartGridPage.qml     # 航图分类网格
│   ├── SearchPage.qml        # 搜索页面
│   └── SettingsPage.qml      # 设置页面
├── components/
│   ├── AirportCard.qml       # 机场卡片组件
│   ├── ChartTypeButton.qml   # 航图类型按钮
│   ├── SearchBar.qml         # 搜索栏
│   └── LoadingIndicator.qml  # 加载动画
└── styles/
    ├── Theme.qml             # 主题配置（单例）
    └── Colors.qml            # 色彩定义
```

**设计原则**:
- 组件化: 可复用组件放在 `components/`
- 单一职责: 每个 QML 文件只负责一个功能
- 状态管理: 使用 `State` 和 `Transition` 管理 UI 状态

#### Python Widgets 组件

**职责**:
- 复杂图形渲染（航图查看器）
- 自定义绘制（标注工具）
- 水印叠加
- 平台特定功能（防截图）

**主要组件**:
```
ui/
├── chart_viewer_widget.py    # 航图查看器（QGraphicsView）
├── annotation_tools.py       # 标注工具栏
├── watermark_overlay.py      # 水印叠加层
└── screenshot_protect.py     # 防截图功能
```

**设计原则**:
- 继承 Qt Widgets 基类
- 暴露信号和槽给 QML 调用
- 使用 QGraphicsView 实现高性能渲染

---

### 2. 控制器层（桥接层）

#### 职责
- 桥接 QML 和 Python 业务逻辑
- 数据格式转换（Python ↔ QML）
- 信号转发和处理

#### 设计模式：Model-View-Controller (MVC)

```
┌──────────┐        ┌──────────────┐        ┌──────────┐
│   View   │◄───────│  Controller  │───────►│  Model   │
│  (QML)   │        │   (Python)   │        │(Service) │
└──────────┘        └──────────────┘        └──────────┘
     │                      │                     │
     │  用户交互             │  业务逻辑调用        │
     └─────────────────────►│◄───────────────────┘
                            │
                       数据更新通知
```

#### 主要控制器

##### AuthController（认证控制器）
```python
class AuthController(QObject):
    """用户认证控制器"""

    # 信号（发送给 QML）
    loginSucceeded = pyqtSignal(str)  # 参数: username
    loginFailed = pyqtSignal(str)     # 参数: error_message
    registerSucceeded = pyqtSignal()
    registerFailed = pyqtSignal(str)

    def __init__(self, parent=None):
        super().__init__(parent)
        self._auth_service = AuthService()  # 业务逻辑服务
        self._username = ""
        self._is_authenticated = False

    # 槽（QML 调用）
    @pyqtSlot(str, str)
    def login(self, username: str, password: str):
        success, message = self._auth_service.login(username, password)
        if success:
            self._username = username
            self._is_authenticated = True
            self.loginSucceeded.emit(username)
        else:
            self.loginFailed.emit(message)

    # 属性（QML 读取）
    @pyqtProperty(bool, notify=loginSucceeded)
    def isAuthenticated(self):
        return self._is_authenticated

    @pyqtProperty(str, notify=loginSucceeded)
    def username(self):
        return self._username
```

**QML 使用示例**:
```qml
import EAIP 1.0

Page {
    AuthController {
        id: authController
    }

    Button {
        text: "登录"
        onClicked: {
            authController.login(usernameField.text, passwordField.text)
        }
    }

    Connections {
        target: authController
        function onLoginSucceeded(username) {
            console.log("登录成功:", username)
            stackView.push("AirportListPage.qml")
        }
        function onLoginFailed(message) {
            errorDialog.text = message
            errorDialog.open()
        }
    }
}
```

##### AirportListModel（机场列表模型）
```python
class AirportListModel(QAbstractListModel):
    """机场列表模型（QML ListView 数据源）"""

    IcaoRole = Qt.ItemDataRole.UserRole + 1
    NameCnRole = Qt.ItemDataRole.UserRole + 2
    NameEnRole = Qt.ItemDataRole.UserRole + 3
    ChartCountRole = Qt.ItemDataRole.UserRole + 4

    def __init__(self, parent=None):
        super().__init__(parent)
        self._airports = []
        self._load_airports()

    def _load_airports(self):
        """从数据库加载机场数据"""
        with DatabaseSession() as session:
            self._airports = session.query(Airport).all()

    def rowCount(self, parent=QModelIndex()):
        return len(self._airports)

    def data(self, index, role=Qt.ItemDataRole.DisplayRole):
        if not index.isValid():
            return None

        airport = self._airports[index.row()]

        if role == self.IcaoRole:
            return airport.icao
        elif role == self.NameCnRole:
            return airport.name_cn
        elif role == self.NameEnRole:
            return airport.name_en
        elif role == self.ChartCountRole:
            return len(airport.charts)

        return None

    def roleNames(self):
        return {
            self.IcaoRole: b"icao",
            self.NameCnRole: b"nameCn",
            self.NameEnRole: b"nameEn",
            self.ChartCountRole: b"chartCount",
        }

    @pyqtSlot(str)
    def filterByKeyword(self, keyword: str):
        """QML 调用的筛选方法"""
        self.beginResetModel()
        # 重新加载筛选后的数据
        with DatabaseSession() as session:
            self._airports = session.query(Airport).filter(
                or_(
                    Airport.icao.like(f"%{keyword}%"),
                    Airport.name_cn.like(f"%{keyword}%"),
                    Airport.name_en.like(f"%{keyword}%"),
                )
            ).all()
        self.endResetModel()
```

---

### 3. 服务层（业务逻辑层）

#### 职责
- 纯粹的业务逻辑实现
- 不依赖 Qt（便于单元测试）
- 数据处理和转换
- 业务规则验证

#### 设计原则
- 单一职责原则（SRP）
- 依赖注入（Dependency Injection）
- 面向接口编程

#### 主要服务

##### AuthService（认证服务）
```python
class AuthService:
    """用户认证服务（纯 Python 业务逻辑）"""

    def __init__(self, db_session=None):
        self.db_session = db_session or DatabaseSession()

    def login(self, username: str, password: str) -> Tuple[bool, str]:
        """
        用户登录

        Returns:
            (success, message)
        """
        # 验证输入
        if not username or not password:
            return False, "用户名和密码不能为空"

        # 查询用户
        with self.db_session() as session:
            user = session.query(User).filter_by(username=username).first()

            if not user:
                return False, "用户名或密码错误"

            # 验证密码
            if not verify_password(password, user.password_hash):
                return False, "用户名或密码错误"

            # 检查账户状态
            if not user.is_active:
                return False, "账户已被禁用"

            # 更新最后登录时间
            user.last_login_at = datetime.utcnow()
            session.commit()

            return True, "登录成功"

    def register(self, username: str, email: str, password: str) -> Tuple[bool, str]:
        """用户注册"""
        # 验证用户名
        if len(username) < 3 or len(username) > 20:
            return False, "用户名长度必须在 3-20 个字符之间"

        # 验证邮箱
        if not self._is_valid_email(email):
            return False, "邮箱格式不正确"

        # 验证密码强度
        if not self._is_strong_password(password):
            return False, "密码强度不足（至少 8 个字符，包含大小写字母和数字）"

        # 检查用户名是否已存在
        with self.db_session() as session:
            if session.query(User).filter_by(username=username).first():
                return False, "用户名已存在"

            if session.query(User).filter_by(email=email).first():
                return False, "邮箱已被注册"

            # 创建用户
            user = User(
                username=username,
                email=email,
                password_hash=hash_password(password)
            )
            session.add(user)
            session.commit()

            return True, "注册成功"

    def _is_valid_email(self, email: str) -> bool:
        """验证邮箱格式"""
        import re
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return re.match(pattern, email) is not None

    def _is_strong_password(self, password: str) -> bool:
        """验证密码强度"""
        if len(password) < 8:
            return False
        has_upper = any(c.isupper() for c in password)
        has_lower = any(c.islower() for c in password)
        has_digit = any(c.isdigit() for c in password)
        return has_upper and has_lower and has_digit
```

##### EncryptionService（加密服务）
```python
class EncryptionService:
    """文件加密解密服务"""

    def __init__(self, master_key: bytes):
        if len(master_key) != 32:
            raise ValueError("主密钥必须是 32 字节")
        self.master_key = master_key

    def encrypt_chart_file(self, input_path: str, output_path: str) -> bool:
        """加密航图文件"""
        try:
            # 生成随机 IV
            iv = os.urandom(16)

            # 创建加密器
            cipher = Cipher(
                algorithms.AES(self.master_key),
                modes.CBC(iv),
                backend=default_backend()
            )
            encryptor = cipher.encryptor()

            # 读取原文件
            with open(input_path, 'rb') as f:
                plaintext = f.read()

            # 填充
            padder = padding.PKCS7(128).padder()
            padded_data = padder.update(plaintext) + padder.finalize()

            # 加密
            ciphertext = encryptor.update(padded_data) + encryptor.finalize()

            # 写入加密文件（IV + 密文）
            with open(output_path, 'wb') as f:
                f.write(iv + ciphertext)

            return True

        except Exception as e:
            logging.error(f"加密文件失败: {e}")
            return False

    def decrypt_chart_file(self, input_path: str) -> Optional[bytes]:
        """解密航图文件（返回字节流，不写入磁盘）"""
        try:
            # 读取加密文件
            with open(input_path, 'rb') as f:
                data = f.read()

            # 提取 IV 和密文
            iv = data[:16]
            ciphertext = data[16:]

            # 创建解密器
            cipher = Cipher(
                algorithms.AES(self.master_key),
                modes.CBC(iv),
                backend=default_backend()
            )
            decryptor = cipher.decryptor()

            # 解密
            padded_plaintext = decryptor.update(ciphertext) + decryptor.finalize()

            # 去除填充
            unpadder = padding.PKCS7(128).unpadder()
            plaintext = unpadder.update(padded_plaintext) + unpadder.finalize()

            return plaintext

        except Exception as e:
            logging.error(f"解密文件失败: {e}")
            return None
```

##### PDFRenderService（PDF 渲染服务）
```python
class PDFRenderService:
    """PDF 渲染服务（集成加密）"""

    def __init__(self, encryption_service: EncryptionService):
        self.encryption_service = encryption_service
        self._cache = {}  # 页面缓存

    def render_encrypted_pdf_page(
        self,
        encrypted_pdf_path: str,
        page_num: int,
        dpi: int = 150
    ) -> Optional[QPixmap]:
        """渲染加密 PDF 的指定页"""

        # 检查缓存
        cache_key = f"{encrypted_pdf_path}:{page_num}:{dpi}"
        if cache_key in self._cache:
            return self._cache[cache_key]

        # 解密 PDF（内存中）
        pdf_data = self.encryption_service.decrypt_chart_file(encrypted_pdf_path)
        if not pdf_data:
            return None

        # 使用 PyMuPDF 打开 PDF（从内存）
        doc = fitz.open(stream=pdf_data, filetype="pdf")

        if page_num >= doc.page_count:
            return None

        page = doc[page_num]

        # 设置缩放比例
        zoom = dpi / 72
        mat = fitz.Matrix(zoom, zoom)

        # 渲染为图像
        pix = page.get_pixmap(matrix=mat, alpha=False)

        # 转换为 QPixmap
        img = QImage(
            pix.samples,
            pix.width,
            pix.height,
            pix.stride,
            QImage.Format.Format_RGB888
        )
        pixmap = QPixmap.fromImage(img)

        # 缓存
        self._cache[cache_key] = pixmap

        doc.close()
        return pixmap

    def clear_cache(self):
        """清除缓存"""
        self._cache.clear()
```

---

### 4. 数据访问层

#### DatabaseSession（数据库会话管理）
```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, scoped_session
from contextlib import contextmanager

class DatabaseManager:
    """数据库管理器（单例）"""

    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._initialize()
        return cls._instance

    def _initialize(self):
        """初始化数据库连接"""
        db_path = "data/database.db"
        self.engine = create_engine(f"sqlite:///{db_path}", echo=False)
        self.Session = scoped_session(sessionmaker(bind=self.engine))

    @contextmanager
    def session_scope(self):
        """提供事务性会话"""
        session = self.Session()
        try:
            yield session
            session.commit()
        except Exception:
            session.rollback()
            raise
        finally:
            session.close()

# 全局实例
db_manager = DatabaseManager()
DatabaseSession = db_manager.session_scope
```

---

## 数据流设计

### 用户登录流程

```
┌─────────┐      ┌────────────────┐      ┌─────────────┐      ┌──────────┐
│  QML    │      │AuthController  │      │AuthService  │      │ Database │
│LoginPage│      │  (Controller)  │      │  (Service)  │      │          │
└────┬────┘      └───────┬────────┘      └──────┬──────┘      └────┬─────┘
     │                   │                      │                   │
     │ 1. 点击登录按钮     │                      │                   │
     ├──────────────────►│                      │                   │
     │ authController.   │                      │                   │
     │ login(user, pwd)  │                      │                   │
     │                   │ 2. 调用业务逻辑       │                   │
     │                   ├─────────────────────►│                   │
     │                   │ login(user, pwd)     │                   │
     │                   │                      │ 3. 查询用户        │
     │                   │                      ├──────────────────►│
     │                   │                      │ SELECT * FROM     │
     │                   │                      │ users WHERE...    │
     │                   │                      │◄──────────────────┤
     │                   │                      │ 返回 User 对象     │
     │                   │                      │                   │
     │                   │                      │ 4. 验证密码        │
     │                   │                      │ verify_password() │
     │                   │                      │                   │
     │                   │                      │ 5. 更新最后登录    │
     │                   │                      ├──────────────────►│
     │                   │                      │ UPDATE users...   │
     │                   │◄─────────────────────┤                   │
     │                   │ (True, "登录成功")    │                   │
     │                   │                      │                   │
     │                   │ 6. 发射信号          │                   │
     │◄──────────────────┤ loginSucceeded.emit()│                   │
     │ onLoginSucceeded  │                      │                   │
     │                   │                      │                   │
     │ 7. 跳转到主页      │                      │                   │
     │ stackView.push()  │                      │                   │
     │                   │                      │                   │
```

### 航图查看流程

```
┌─────────┐  ┌──────────────┐  ┌───────────────┐  ┌──────────────┐
│  QML    │  │ChartViewer   │  │PDFRenderService│ │EncryptService│
│ChartPage│  │ Widget       │  │               │  │              │
└────┬────┘  └──────┬───────┘  └───────┬───────┘  └──────┬───────┘
     │              │                  │                  │
     │ 1. 打开航图   │                  │                  │
     ├─────────────►│                  │                  │
     │ loadChart()  │                  │                  │
     │              │ 2. 请求渲染       │                  │
     │              ├─────────────────►│                  │
     │              │ render_page()    │                  │
     │              │                  │ 3. 解密文件       │
     │              │                  ├─────────────────►│
     │              │                  │ decrypt_file()   │
     │              │                  │◄─────────────────┤
     │              │                  │ 返回 PDF 字节流   │
     │              │                  │                  │
     │              │                  │ 4. 渲染为图像     │
     │              │                  │ PyMuPDF 渲染     │
     │              │◄─────────────────┤                  │
     │              │ 返回 QPixmap     │                  │
     │              │                  │                  │
     │              │ 5. 添加水印       │                  │
     │              │ drawWatermark()  │                  │
     │              │                  │                  │
     │◄─────────────┤ 6. 显示在界面     │                  │
     │ 航图已加载    │                  │                  │
     │              │                  │                  │
```

---

## 安全架构

### 多层安全防护

```
┌────────────────────────────────────────────────────┐
│               用户层安全                            │
│  - 密码强度验证                                     │
│  - 密码哈希存储（PBKDF2 + Salt）                    │
│  - 会话超时机制                                     │
└────────────────────────────────────────────────────┘
                        ↓
┌────────────────────────────────────────────────────┐
│               传输层安全                            │
│  - HTTPS 加密通信（OTA 更新）                       │
│  - 证书验证                                         │
└────────────────────────────────────────────────────┘
                        ↓
┌────────────────────────────────────────────────────┐
│               存储层安全                            │
│  - 航图文件 AES-256 加密                            │
│  - 数据库敏感字段加密                               │
│  - 密钥分离存储                                     │
└────────────────────────────────────────────────────┘
                        ↓
┌────────────────────────────────────────────────────┐
│               运行时安全                            │
│  - 内存中解密（不写入磁盘）                          │
│  - 水印追溯机制                                     │
│  - 防截图保护                                       │
│  - 禁用右键菜单和打印                               │
└────────────────────────────────────────────────────┘
```

### 密钥管理方案

```python
class KeyManager:
    """密钥管理器"""

    @staticmethod
    def generate_master_key() -> bytes:
        """生成主密钥（首次使用时）"""
        return os.urandom(32)

    @staticmethod
    def derive_key_from_password(password: str, salt: bytes) -> bytes:
        """从用户���码派生密钥（PBKDF2）"""
        from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
        from cryptography.hazmat.primitives import hashes

        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
            backend=default_backend()
        )
        return kdf.derive(password.encode())

    @staticmethod
    def store_encrypted_key(master_key: bytes, user_password: str):
        """使用用户密码加密存储主密钥"""
        salt = os.urandom(16)
        derived_key = KeyManager.derive_key_from_password(user_password, salt)

        # 使用派生密钥加密主密钥
        iv = os.urandom(16)
        cipher = Cipher(
            algorithms.AES(derived_key),
            modes.CBC(iv),
            backend=default_backend()
        )
        encryptor = cipher.encryptor()

        padder = padding.PKCS7(128).padder()
        padded_key = padder.update(master_key) + padder.finalize()

        encrypted_key = encryptor.update(padded_key) + encryptor.finalize()

        # 保存 salt + iv + encrypted_key
        with open("data/master.key", 'wb') as f:
            f.write(salt + iv + encrypted_key)
```

---

## 性能优化策略

### 1. 渲染优化
- 多级缓存（内存缓存 + 磁盘缓存）
- 异步渲染（后台线程）
- 按需加载（仅渲染可见页面）
- LOD（Level of Detail）策略

### 2. 数据库优化
- 索引优化（ICAO、chart_type、effective_date）
- 查询缓存
- 连接池管理
- 批量操作

### 3. 内存优化
- 弱引用缓存
- LRU 缓存淘汰策略
- 及时释放大对象

### 4. 启动优化
- 延迟加载非核心模块
- 预加载常用数据
- 异步初始化

---

## 可扩展性设计

### 插件系统（v2.0 规划）

```python
class PluginInterface:
    """插件接口"""

    def on_load(self):
        """插件加载时调用"""
        pass

    def on_chart_opened(self, chart_id: int):
        """航图打开时调用"""
        pass

    def add_menu_items(self) -> List[MenuItem]:
        """添加菜单项"""
        return []
```

### 主题系统
- QML 主题文件
- 动态切换主题
- 自定义颜色方案

### 国际化（i18n）
- Qt Linguist 翻译工具
- 动态语言切换
- 日期/时间本地化

---

更多详细设计请参考源码注释。