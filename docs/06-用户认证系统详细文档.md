# EAIP Viewer 用户认证系统详细文档

## 目录
- [认证系统概述](#认证系统概述)
- [安全设计原则](#安全设计原则)
- [数据模型设计](#数据模型设计)
- [密码加密方案](#密码加密方案)
- [认证服务实现](#认证服务实现)
- [QML 控制器实现](#qml-控制器实现)
- [前端界面实现](#前端界面实现)
- [会话管理](#会话管理)
- [游客模式实现](#游客模式实现)
- [安全加固措施](#安全加固措施)
- [测试方案](#测试方案)
- [部署清单](#部署清单)

---

## 认证系统概述

### 功能需求

#### 用户注册
- 用户名、邮箱、密码输入
- 输入验证（格式、长度、强度）
- 重复检查（用户名、邮箱唯一性）
- 密码二次确认
- 用户协议确认

#### 用户登录
- 用户名/邮箱登录
- 密码验证
- "记住我"功能（自动登录）
- 登录失败提示
- 账户状态检查（是否禁用）

#### 游客模式
- 无需注册即可访问
- 功能受限（部分航图、无标注、无收藏）
- 随时可升级为正式用户

#### 会话管理
- 登录状态持久化
- 会话过期检查（30 天）
- 自动登出机制
- 多设备登录支持（可选）

### 技术架构

```
┌─────────────────────────────────────────────────────────┐
│                   QML UI 层                              │
│  LoginPage.qml / RegisterPage.qml                        │
│  - 用户输入表单                                           │
│  - 验证提示信息                                           │
│  - 加载动画                                               │
└────────────────────┬────────────────────────────────────┘
                     │ Signals & Slots
┌────────────────────▼────────────────────────────────────┐
│                AuthController (桥接层)                    │
│  - login(username, password)                             │
│  - register(username, email, password)                   │
│  - loginSucceeded / loginFailed 信号                     │
│  - registerSucceeded / registerFailed 信号               │
└────────────────────┬────────────────────────────────────┘
                     │ Business Logic
┌────────────────────▼────────────────────────────────────┐
│              AuthService (业务逻辑层)                     │
│  - login(username, password) -> (bool, str)              │
│  - register(...) -> (bool, str)                          │
│  - validate_password(password, hash) -> bool             │
│  - check_session_valid() -> bool                         │
└────────────────────┬────────────────────────────────────┘
                     │ Data Access
┌────────────────────▼────────────────────────────────────┐
│                 User Model (ORM)                         │
│  SQLAlchemy ORM → SQLite Database                        │
│  - users 表（id, username, email, password_hash, ...）   │
└─────────────────────────────────────────────────────────┘
```

---

## 安全设计原则

### 1. 密码存储安全

#### 永不存储明文密码
```python
# ❌ 错误做法
user.password = "password123"  # 明文存储

# ✅ 正确做法
user.password_hash = hash_password("password123")  # 哈希存储
```

#### 使用强哈希算法
- **PBKDF2** (Password-Based Key Derivation Function 2)
- 迭代次数: 100,000+
- Salt: 随机生成，每个用户不同
- 哈希算法: SHA-256

### 2. 输入验证

#### 客户端验证（QML）
- 即时反馈，提升用户体验
- 不能作为唯一防线

#### 服务端验证（Python）
- 所有输入必须重新验证
- 防止绕过客户端验证

### 3. 会话安全

#### Token 生成
- 使用 UUID4 生成唯一 Token
- 存储在安全的本地位置
- 设置过期时间

#### Token 验证
- 每次请求验证 Token 有效性
- 检查是否过期
- 检查用户是否被禁用

### 4. 防暴力破解

#### 登录尝试限制
- 5 次失败后锁定 15 分钟
- IP 级别限制（可选）
- 验证码机制（v1.1）

---

## 数据模型设计

### User 模型（SQLAlchemy ORM）

**文件**: `src/models/user.py`

```python
from sqlalchemy import Column, Integer, String, DateTime, Boolean, Text
from sqlalchemy.ext.declarative import declarative_base
from datetime import datetime
import uuid

Base = declarative_base()

class User(Base):
    """用户模型"""

    __tablename__ = 'users'

    # 主键
    id = Column(Integer, primary_key=True, autoincrement=True)

    # 基本信息
    username = Column(String(50), unique=True, nullable=False, index=True)
    email = Column(String(100), unique=True, nullable=False, index=True)

    # 安全字段
    password_hash = Column(String(255), nullable=False)  # PBKDF2 哈希
    password_salt = Column(String(32), nullable=False)   # 随机 Salt

    # 会话管理
    session_token = Column(String(36), nullable=True, unique=True)  # UUID
    session_expires_at = Column(DateTime, nullable=True)

    # 时间戳
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    last_login_at = Column(DateTime, nullable=True)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # 状态
    is_active = Column(Boolean, default=True, nullable=False)
    is_guest = Column(Boolean, default=False, nullable=False)

    # 登录失败计数（防暴力破解）
    login_attempts = Column(Integer, default=0)
    locked_until = Column(DateTime, nullable=True)

    # 用户偏好设置（JSON 格式）
    preferences = Column(Text, nullable=True)  # JSON string

    def __repr__(self):
        return f"<User(id={self.id}, username='{self.username}')>"

    # 业务方法

    def update_last_login(self):
        """更新最后登录时间"""
        self.last_login_at = datetime.utcnow()
        self.login_attempts = 0  # 重置失败次数

    def increment_login_attempts(self):
        """增加登录失败次数"""
        self.login_attempts += 1
        if self.login_attempts >= 5:
            from datetime import timedelta
            self.locked_until = datetime.utcnow() + timedelta(minutes=15)

    def is_locked(self) -> bool:
        """检查账户是否被锁定"""
        if self.locked_until:
            if datetime.utcnow() < self.locked_until:
                return True
            else:
                # 锁定时间已过，解锁
                self.locked_until = None
                self.login_attempts = 0
        return False

    def generate_session_token(self, remember_me: bool = False):
        """生成会话 Token"""
        self.session_token = str(uuid.uuid4())

        from datetime import timedelta
        if remember_me:
            # 记住我：30 天
            self.session_expires_at = datetime.utcnow() + timedelta(days=30)
        else:
            # 不记住：24 小时
            self.session_expires_at = datetime.utcnow() + timedelta(hours=24)

        return self.session_token

    def is_session_valid(self) -> bool:
        """检查会话是否有效"""
        if not self.session_token:
            return False
        if not self.session_expires_at:
            return False
        if datetime.utcnow() > self.session_expires_at:
            return False
        return True

    def clear_session(self):
        """清除会话（登出）"""
        self.session_token = None
        self.session_expires_at = None
```

### 数据库迁移脚本

**文件**: `alembic/versions/001_create_users_table.py`

```python
"""create users table

Revision ID: 001
Revises:
Create Date: 2024-01-01 00:00:00.000000

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = '001'
down_revision = None
branch_labels = None
depends_on = None

def upgrade():
    op.create_table(
        'users',
        sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),
        sa.Column('username', sa.String(length=50), nullable=False),
        sa.Column('email', sa.String(length=100), nullable=False),
        sa.Column('password_hash', sa.String(length=255), nullable=False),
        sa.Column('password_salt', sa.String(length=32), nullable=False),
        sa.Column('session_token', sa.String(length=36), nullable=True),
        sa.Column('session_expires_at', sa.DateTime(), nullable=True),
        sa.Column('created_at', sa.DateTime(), nullable=False),
        sa.Column('last_login_at', sa.DateTime(), nullable=True),
        sa.Column('updated_at', sa.DateTime(), nullable=False),
        sa.Column('is_active', sa.Boolean(), nullable=False),
        sa.Column('is_guest', sa.Boolean(), nullable=False),
        sa.Column('login_attempts', sa.Integer(), nullable=True),
        sa.Column('locked_until', sa.DateTime(), nullable=True),
        sa.Column('preferences', sa.Text(), nullable=True),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('username'),
        sa.UniqueConstraint('email'),
        sa.UniqueConstraint('session_token')
    )

    # 创建索引
    op.create_index('idx_username', 'users', ['username'])
    op.create_index('idx_email', 'users', ['email'])
    op.create_index('idx_session_token', 'users', ['session_token'])

def downgrade():
    op.drop_index('idx_session_token')
    op.drop_index('idx_email')
    op.drop_index('idx_username')
    op.drop_table('users')
```

---

## 密码加密方案

### 加密工具类

**文件**: `src/utils/crypto_helper.py`

```python
import os
import hashlib
from typing import Tuple

def hash_password(password: str, salt: str = None) -> Tuple[str, str]:
    """
    使用 PBKDF2 哈希密码

    Args:
        password: 明文密码
        salt: 盐值（可选，不提供则自动生成）

    Returns:
        (hash, salt): 哈希值和盐值
    """
    if salt is None:
        salt = os.urandom(16).hex()  # 生成 16 字节随机盐

    # PBKDF2-HMAC-SHA256
    # iterations=100000 (NIST 推荐最少 10000，我们使用 100000)
    hash_obj = hashlib.pbkdf2_hmac(
        'sha256',
        password.encode('utf-8'),
        salt.encode('utf-8'),
        iterations=100000
    )

    password_hash = hash_obj.hex()

    return password_hash, salt


def verify_password(password: str, stored_hash: str, stored_salt: str) -> bool:
    """
    验证密码

    Args:
        password: 用户输入的密码
        stored_hash: 存储的哈希值
        stored_salt: 存储的盐值

    Returns:
        bool: 密码是否正确
    """
    # 使用相同的盐值计算哈希
    computed_hash, _ = hash_password(password, stored_salt)

    # 使用常数时间比较（防止时序攻击）
    return hmac.compare_digest(computed_hash, stored_hash)


import hmac  # 导入 hmac 用于安全比较
```

### 密码强度验证

**文件**: `src/utils/password_validator.py`

```python
import re
from typing import Tuple

class PasswordValidator:
    """密码强度验证器"""

    MIN_LENGTH = 8
    MAX_LENGTH = 128

    @staticmethod
    def validate(password: str) -> Tuple[bool, str]:
        """
        验证密码强度

        Returns:
            (is_valid, error_message)
        """
        # 长度检查
        if len(password) < PasswordValidator.MIN_LENGTH:
            return False, f"密码长度至少 {PasswordValidator.MIN_LENGTH} 个字符"

        if len(password) > PasswordValidator.MAX_LENGTH:
            return False, f"密码长度不能超过 {PasswordValidator.MAX_LENGTH} 个字符"

        # 必须包含大写字母
        if not re.search(r'[A-Z]', password):
            return False, "密码必须包含至少一个大写字母"

        # 必须包含小写字母
        if not re.search(r'[a-z]', password):
            return False, "密码必须包含至少一个小写字母"

        # 必须包含数字
        if not re.search(r'[0-9]', password):
            return False, "密码必须包含至少一个数字"

        # 可选：包含特殊字符（提高安全性）
        # if not re.search(r'[!@#$%^&*()_+\-=\[\]{};:\'",.<>?]', password):
        #     return False, "密码应包含至少一个特殊字符"

        # 检查常见弱密码
        weak_passwords = [
            'password', '12345678', 'qwerty', 'admin', 'letmein',
            'welcome', 'monkey', '1234567890', 'Password123'
        ]
        if password.lower() in [wp.lower() for wp in weak_passwords]:
            return False, "密码过于简单，请使用更复杂的密码"

        return True, "密码强度符合要求"
```

---

## 认证服务实现

### AuthService 核心类

**文件**: `src/core/auth.py`

```python
from typing import Tuple, Optional
from models.user import User
from utils.crypto_helper import hash_password, verify_password
from utils.password_validator import PasswordValidator
from core.database import DatabaseSession
import re
import logging

logger = logging.getLogger(__name__)

class AuthService:
    """用户认证服务（纯 Python 业务逻辑）"""

    def __init__(self):
        pass

    # ==================== 用户注册 ====================

    def register(
        self,
        username: str,
        email: str,
        password: str,
        password_confirm: str
    ) -> Tuple[bool, str]:
        """
        用户注册

        Args:
            username: 用户名
            email: 邮箱
            password: 密码
            password_confirm: 确认密码

        Returns:
            (success, message)
        """
        # 1. 验证输入
        is_valid, error_msg = self._validate_registration_input(
            username, email, password, password_confirm
        )
        if not is_valid:
            return False, error_msg

        # 2. 检查用户名和邮箱是否已存在
        with DatabaseSession() as session:
            if session.query(User).filter_by(username=username).first():
                return False, "用户名已存在"

            if session.query(User).filter_by(email=email).first():
                return False, "邮箱已被注册"

            # 3. 创建用户
            password_hash, password_salt = hash_password(password)

            user = User(
                username=username,
                email=email,
                password_hash=password_hash,
                password_salt=password_salt,
                is_active=True,
                is_guest=False
            )

            session.add(user)
            session.commit()

            logger.info(f"用户注册成功: {username}")
            return True, "注册成功"

    def _validate_registration_input(
        self,
        username: str,
        email: str,
        password: str,
        password_confirm: str
    ) -> Tuple[bool, str]:
        """验证注册输入"""

        # 验证用户名
        if not username or len(username) < 3:
            return False, "用户名至少 3 个字符"

        if len(username) > 20:
            return False, "用户名不能超过 20 个字符"

        if not re.match(r'^[a-zA-Z0-9_]+$', username):
            return False, "用户名只能包含字母、数字和下划线"

        # 验证邮箱
        if not self._is_valid_email(email):
            return False, "邮箱格式不正确"

        # 验证密码
        is_valid, error_msg = PasswordValidator.validate(password)
        if not is_valid:
            return False, error_msg

        # 验证密码确认
        if password != password_confirm:
            return False, "两次输入的密码不一致"

        return True, ""

    def _is_valid_email(self, email: str) -> bool:
        """验证邮箱格式"""
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return re.match(pattern, email) is not None

    # ==================== 用户登录 ====================

    def login(
        self,
        username_or_email: str,
        password: str,
        remember_me: bool = False
    ) -> Tuple[bool, str, Optional[str]]:
        """
        用户登录

        Args:
            username_or_email: 用户名或邮箱
            password: 密码
            remember_me: 是否记住我

        Returns:
            (success, message, session_token)
        """
        # 1. 验证输入
        if not username_or_email or not password:
            return False, "用户名和密码不能为空", None

        # 2. 查询用户
        with DatabaseSession() as session:
            # 判断是邮箱还是用户名
            if '@' in username_or_email:
                user = session.query(User).filter_by(email=username_or_email).first()
            else:
                user = session.query(User).filter_by(username=username_or_email).first()

            if not user:
                logger.warning(f"登录失败: 用户不存在 {username_or_email}")
                return False, "用户名或密码错误", None

            # 3. 检查账户状态
            if not user.is_active:
                return False, "账户已被禁用，请联系管理员", None

            # 检查是否被锁定
            if user.is_locked():
                lock_time = (user.locked_until - datetime.utcnow()).seconds // 60
                return False, f"账户已被锁定，请 {lock_time} 分钟后重试", None

            # 4. 验证密码
            if not verify_password(password, user.password_hash, user.password_salt):
                user.increment_login_attempts()
                session.commit()

                logger.warning(f"登录失败: 密码错误 {username_or_email}")
                return False, "用户名或密码错误", None

            # 5. 登录成功
            user.update_last_login()
            token = user.generate_session_token(remember_me)
            session.commit()

            logger.info(f"用户登录成功: {user.username}")
            return True, "登录成功", token

    # ==================== 会话验证 ====================

    def verify_session(self, session_token: str) -> Optional[User]:
        """
        验证会话 Token

        Args:
            session_token: 会话 Token

        Returns:
            User 对象或 None
        """
        if not session_token:
            return None

        with DatabaseSession() as session:
            user = session.query(User).filter_by(session_token=session_token).first()

            if not user:
                return None

            # 检查会话是否有效
            if not user.is_session_valid():
                logger.info(f"会话已过期: {user.username}")
                return None

            # 检查账户状态
            if not user.is_active:
                return None

            return user

    # ==================== 登出 ====================

    def logout(self, session_token: str) -> bool:
        """
        用户登出

        Args:
            session_token: 会话 Token

        Returns:
            bool: 是否成功
        """
        with DatabaseSession() as session:
            user = session.query(User).filter_by(session_token=session_token).first()

            if user:
                user.clear_session()
                session.commit()
                logger.info(f"用户登出: {user.username}")
                return True

            return False

    # ==================== 游客模式 ====================

    def create_guest_user(self) -> Tuple[bool, str, Optional[str]]:
        """
        创建游客用户

        Returns:
            (success, message, session_token)
        """
        import uuid
        guest_username = f"guest_{uuid.uuid4().hex[:8]}"

        with DatabaseSession() as session:
            # 创建游客账户
            password_hash, password_salt = hash_password(str(uuid.uuid4()))

            guest_user = User(
                username=guest_username,
                email=f"{guest_username}@guest.local",
                password_hash=password_hash,
                password_salt=password_salt,
                is_active=True,
                is_guest=True
            )

            token = guest_user.generate_session_token(remember_me=False)
            session.add(guest_user)
            session.commit()

            logger.info(f"创建游客用户: {guest_username}")
            return True, "游客模式已启用", token

    # ==================== 密码管理 ====================

    def change_password(
        self,
        user_id: int,
        old_password: str,
        new_password: str,
        new_password_confirm: str
    ) -> Tuple[bool, str]:
        """
        修改密码

        Args:
            user_id: 用户 ID
            old_password: 旧密码
            new_password: 新密码
            new_password_confirm: 确认新密码

        Returns:
            (success, message)
        """
        # 验证新密码
        is_valid, error_msg = PasswordValidator.validate(new_password)
        if not is_valid:
            return False, error_msg

        if new_password != new_password_confirm:
            return False, "两次输入的新密码不一致"

        with DatabaseSession() as session:
            user = session.query(User).filter_by(id=user_id).first()

            if not user:
                return False, "用户不存在"

            # 验证旧密码
            if not verify_password(old_password, user.password_hash, user.password_salt):
                return False, "旧密码错误"

            # 更新密码
            password_hash, password_salt = hash_password(new_password)
            user.password_hash = password_hash
            user.password_salt = password_salt

            # 清除所有会话（强制重新登录）
            user.clear_session()

            session.commit()

            logger.info(f"用户修改密码: {user.username}")
            return True, "密码修改成功，请重新登录"


# 全局单例实例
auth_service = AuthService()
```

---

## QML 控制器实现

### AuthController

**文件**: `src/controllers/auth_controller.py`

```python
from PyQt6.QtCore import QObject, pyqtSignal, pyqtSlot, pyqtProperty
from core.auth import auth_service
from models.user import User
import logging

logger = logging.getLogger(__name__)

class AuthController(QObject):
    """用户认证控制器（QML 桥接层）"""

    # ==================== 信号 ====================

    # 登录相关信号
    loginSucceeded = pyqtSignal(str)  # 参数: username
    loginFailed = pyqtSignal(str)     # 参数: error_message

    # 注册相关信号
    registerSucceeded = pyqtSignal()
    registerFailed = pyqtSignal(str)

    # 登出信号
    logoutSucceeded = pyqtSignal()

    # 认证状态变化信号
    authenticationChanged = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self._username = ""
        self._email = ""
        self._is_authenticated = False
        self._is_guest = False
        self._session_token = ""

        # 尝试恢复会话
        self._restore_session()

    # ==================== QML 调用的槽函数 ====================

    @pyqtSlot(str, str, bool)
    def login(self, username: str, password: str, remember_me: bool = False):
        """
        登录（QML 调用）

        Args:
            username: 用户名或邮箱
            password: 密码
            remember_me: 是否记住我
        """
        logger.info(f"尝试登录: {username}")

        success, message, token = auth_service.login(
            username, password, remember_me
        )

        if success:
            # 登录成功
            user = auth_service.verify_session(token)
            if user:
                self._username = user.username
                self._email = user.email
                self._is_authenticated = True
                self._is_guest = user.is_guest
                self._session_token = token

                # 保存 Token 到本地
                self._save_session_token(token)

                self.authenticationChanged.emit()
                self.loginSucceeded.emit(user.username)
        else:
            # 登录失败
            self.loginFailed.emit(message)

    @pyqtSlot(str, str, str, str)
    def register(
        self,
        username: str,
        email: str,
        password: str,
        password_confirm: str
    ):
        """
        注册（QML 调用）
        """
        logger.info(f"尝试注册: {username}")

        success, message = auth_service.register(
            username, email, password, password_confirm
        )

        if success:
            self.registerSucceeded.emit()

            # 注册成功后自动登录
            self.login(username, password, False)
        else:
            self.registerFailed.emit(message)

    @pyqtSlot()
    def loginAsGuest(self):
        """游客模式登录（QML 调用）"""
        logger.info("启用游客模式")

        success, message, token = auth_service.create_guest_user()

        if success:
            user = auth_service.verify_session(token)
            if user:
                self._username = user.username
                self._email = user.email
                self._is_authenticated = True
                self._is_guest = True
                self._session_token = token

                self.authenticationChanged.emit()
                self.loginSucceeded.emit(user.username)
        else:
            self.loginFailed.emit(message)

    @pyqtSlot()
    def logout(self):
        """登出（QML 调用）"""
        logger.info(f"用户登出: {self._username}")

        auth_service.logout(self._session_token)

        self._username = ""
        self._email = ""
        self._is_authenticated = False
        self._is_guest = False
        self._session_token = ""

        # 清除本地 Token
        self._clear_session_token()

        self.authenticationChanged.emit()
        self.logoutSucceeded.emit()

    # ==================== 属性（QML 读取）====================

    @pyqtProperty(bool, notify=authenticationChanged)
    def isAuthenticated(self):
        """是否已认证"""
        return self._is_authenticated

    @pyqtProperty(bool, notify=authenticationChanged)
    def isGuest(self):
        """是否为游客"""
        return self._is_guest

    @pyqtProperty(str, notify=authenticationChanged)
    def username(self):
        """当前用户名"""
        return self._username

    @pyqtProperty(str, notify=authenticationChanged)
    def email(self):
        """当前邮箱"""
        return self._email

    # ==================== 会话管理 ====================

    def _restore_session(self):
        """恢复会话（从本地读取 Token）"""
        token = self._load_session_token()
        if token:
            user = auth_service.verify_session(token)
            if user:
                self._username = user.username
                self._email = user.email
                self._is_authenticated = True
                self._is_guest = user.is_guest
                self._session_token = token
                self.authenticationChanged.emit()
                logger.info(f"会话已恢复: {user.username}")

    def _save_session_token(self, token: str):
        """保存 Token 到本地文件"""
        import os
        token_file = "data/session.token"
        os.makedirs(os.path.dirname(token_file), exist_ok=True)

        with open(token_file, 'w') as f:
            f.write(token)

    def _load_session_token(self) -> str:
        """从本地文件加载 Token"""
        token_file = "data/session.token"
        try:
            with open(token_file, 'r') as f:
                return f.read().strip()
        except FileNotFoundError:
            return ""

    def _clear_session_token(self):
        """清除本地 Token 文件"""
        import os
        token_file = "data/session.token"
        if os.path.exists(token_file):
            os.remove(token_file)
```

---

## 前端界面实现

### 登录页面

**文件**: `src/qml/pages/LoginPage.qml`

```qml
import QtQuick 2.15
import QtQuick.Controls 2.15
import QtQuick.Layouts 1.15
import EAIP 1.0
import "../components"
import "../styles"

Page {
    id: loginPage

    // 认证控制器
    AuthController {
        id: authController

        onLoginSucceeded: function(username) {
            console.log("登录成功:", username)
            loadingIndicator.visible = false
            stackView.replace("AirportListPage.qml")
        }

        onLoginFailed: function(message) {
            console.log("登录失败:", message)
            loadingIndicator.visible = false
            errorDialog.text = message
            errorDialog.open()
        }
    }

    // 主布局
    Rectangle {
        anchors.fill: parent
        color: Theme.backgroundColor

        ColumnLayout {
            anchors.centerIn: parent
            width: 400
            spacing: Theme.spacingLarge

            // Logo
            Image {
                Layout.alignment: Qt.AlignHCenter
                source: "qrc:/resources/icons/app_logo.png"
                width: 120
                height: 120
            }

            // 标题
            Text {
                Layout.alignment: Qt.AlignHCenter
                text: "EAIP Viewer"
                font.pixelSize: Theme.fontSizeTitle
                font.bold: true
                color: Theme.textColor
            }

            // 用户名输入框
            TextField {
                id: usernameField
                Layout.fillWidth: true
                placeholderText: "用户名或邮箱"
                font.pixelSize: Theme.fontSizeNormal

                Keys.onReturnPressed: passwordField.forceActiveFocus()
            }

            // 密码输入框
            TextField {
                id: passwordField
                Layout.fillWidth: true
                placeholderText: "密码"
                echoMode: TextInput.Password
                font.pixelSize: Theme.fontSizeNormal

                Keys.onReturnPressed: loginButton.clicked()
            }

            // 记住我
            CheckBox {
                id: rememberMeCheckBox
                text: "记住我"
                checked: false
            }

            // 登录按钮
            Button {
                id: loginButton
                Layout.fillWidth: true
                text: "登录"
                font.pixelSize: Theme.fontSizeNormal
                highlighted: true

                onClicked: {
                    if (usernameField.text === "" || passwordField.text === "") {
                        errorDialog.text = "请输入用户名和密码"
                        errorDialog.open()
                        return
                    }

                    loadingIndicator.visible = true
                    authController.login(
                        usernameField.text,
                        passwordField.text,
                        rememberMeCheckBox.checked
                    )
                }
            }

            // 游客模式按钮
            Button {
                Layout.fillWidth: true
                text: "游客模式"
                flat: true

                onClicked: {
                    loadingIndicator.visible = true
                    authController.loginAsGuest()
                }
            }

            // 分隔线
            Rectangle {
                Layout.fillWidth: true
                height: 1
                color: "#E0E0E0"
            }

            // 注册链接
            RowLayout {
                Layout.alignment: Qt.AlignHCenter
                spacing: 5

                Text {
                    text: "还没有账户？"
                    font.pixelSize: Theme.fontSizeSmall
                    color: Theme.textColor
                }

                Text {
                    text: "立即注册"
                    font.pixelSize: Theme.fontSizeSmall
                    color: Theme.primaryColor
                    font.underline: true

                    MouseArea {
                        anchors.fill: parent
                        cursorShape: Qt.PointingHandCursor
                        onClicked: {
                            stackView.push("RegisterPage.qml")
                        }
                    }
                }
            }

            // 忘记密码链接
            Text {
                Layout.alignment: Qt.AlignHCenter
                text: "忘记密码？"
                font.pixelSize: Theme.fontSizeSmall
                color: Theme.primaryColor
                font.underline: true

                MouseArea {
                    anchors.fill: parent
                    cursorShape: Qt.PointingHandCursor
                    onClicked: {
                        // TODO: 实现忘记密码功能
                        console.log("忘记密码")
                    }
                }
            }
        }

        // 加载指示器
        BusyIndicator {
            id: loadingIndicator
            anchors.centerIn: parent
            visible: false
            running: visible
        }
    }

    // 错误对话框
    Dialog {
        id: errorDialog
        title: "登录失败"
        standardButtons: Dialog.Ok
        modal: true
        anchors.centerIn: parent

        property alias text: errorText.text

        Text {
            id: errorText
            font.pixelSize: Theme.fontSizeNormal
        }
    }
}
```

### 注册页面

**文件**: `src/qml/pages/RegisterPage.qml`

```qml
import QtQuick 2.15
import QtQuick.Controls 2.15
import QtQuick.Layouts 1.15
import EAIP 1.0
import "../styles"

Page {
    id: registerPage

    AuthController {
        id: authController

        onRegisterSucceeded: {
            // 注册成功后会自动登录，跳转到主页
            stackView.replace("AirportListPage.qml")
        }

        onRegisterFailed: function(message) {
            errorDialog.text = message
            errorDialog.open()
        }
    }

    Rectangle {
        anchors.fill: parent
        color: Theme.backgroundColor

        ColumnLayout {
            anchors.centerIn: parent
            width: 400
            spacing: Theme.spacingNormal

            Text {
                Layout.alignment: Qt.AlignHCenter
                text: "注册新账户"
                font.pixelSize: Theme.fontSizeLarge
                font.bold: true
            }

            TextField {
                id: usernameField
                Layout.fillWidth: true
                placeholderText: "用户名（3-20个字符）"
            }

            TextField {
                id: emailField
                Layout.fillWidth: true
                placeholderText: "邮箱地址"
            }

            TextField {
                id: passwordField
                Layout.fillWidth: true
                placeholderText: "密码（至少8个字符）"
                echoMode: TextInput.Password
            }

            TextField {
                id: passwordConfirmField
                Layout.fillWidth: true
                placeholderText: "确认密码"
                echoMode: TextInput.Password
            }

            CheckBox {
                id: agreeCheckBox
                text: "我已阅读并同意用户协议"
            }

            Button {
                Layout.fillWidth: true
                text: "注册"
                highlighted: true
                enabled: agreeCheckBox.checked

                onClicked: {
                    authController.register(
                        usernameField.text,
                        emailField.text,
                        passwordField.text,
                        passwordConfirmField.text
                    )
                }
            }

            Text {
                Layout.alignment: Qt.AlignHCenter
                text: "已有账户？返回登录"
                color: Theme.primaryColor
                font.underline: true

                MouseArea {
                    anchors.fill: parent
                    onClicked: stackView.pop()
                }
            }
        }
    }

    Dialog {
        id: errorDialog
        title: "注册失败"
        standardButtons: Dialog.Ok
        property alias text: errorText.text
        Text { id: errorText }
    }
}
```

---

## 测试方案

### 单元测试

**文件**: `tests/test_auth.py`

```python
import pytest
from core.auth import AuthService
from models.user import User
from core.database import DatabaseSession

class TestAuthService:
    """认证服务测试"""

    @pytest.fixture
    def auth_service(self):
        return AuthService()

    def test_register_success(self, auth_service):
        """测试注册成功"""
        success, message = auth_service.register(
            "testuser",
            "test@example.com",
            "Password123",
            "Password123"
        )
        assert success is True

    def test_register_duplicate_username(self, auth_service):
        """测试重复用户名"""
        # 第一次注册
        auth_service.register("testuser2", "test2@example.com", "Password123", "Password123")

        # 第二次注册相同用户名
        success, message = auth_service.register("testuser2", "other@example.com", "Password123", "Password123")
        assert success is False
        assert "用户名已存在" in message

    def test_login_success(self, auth_service):
        """测试登录成功"""
        # 先注册
        auth_service.register("logintest", "login@example.com", "Password123", "Password123")

        # 再登录
        success, message, token = auth_service.login("logintest", "Password123")
        assert success is True
        assert token is not None

    def test_login_wrong_password(self, auth_service):
        """测试密码错误"""
        auth_service.register("pwdtest", "pwd@example.com", "Password123", "Password123")

        success, message, token = auth_service.login("pwdtest", "WrongPassword")
        assert success is False
        assert token is None
```

---

## 部署清单

### 1. 数据库初始化

```bash
# 运行数据库迁移
alembic upgrade head

# 或运行初始化脚本
python scripts/init_database.py
```

### 2. 配置环境变量

```bash
# .env 文件
DATABASE_URL=sqlite:///./data/database.db
LOG_LEVEL=INFO
SESSION_TOKEN_EXPIRY=2592000  # 30天
```

### 3. 在 main.py 中注册控制器

```python
from PyQt6.QtQml import qmlRegisterType
from controllers.auth_controller import AuthController

qmlRegisterType(AuthController, "EAIP", 1, 0, "AuthController")
```

### 4. 测试清单

- [ ] 用户注册功能测试
- [ ] 用户登录功能测试
- [ ] 游客模式测试
- [ ] 会话恢复测试
- [ ] 登出功能测试
- [ ] 密码强度验证测试
- [ ] 防暴力破解测试

---

**用户认证系统实现完成！**

此文档提供了用户认证模块的完整实现，包括数据模型、加密方案、业务逻辑、QML 控制器、前端界面、测试方案等关键步骤。