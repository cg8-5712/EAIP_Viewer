# 航图加密方案详细设计

## 文档信息

- **文档版本**: v1.0
- **创建日期**: 2025-10-01
- **最后更新**: 2025-10-01
- **状态**: 设计阶段

---

## 目录

1. [概述](#1-概述)
2. [加密架构](#2-加密架构)
3. [AIPKG 文件格式](#3-aipkg-文件格式)
4. [密钥管理](#4-密钥管理)
5. [工作流程](#5-工作流程)
6. [安全特性](#6-安全特性)
7. [性能优化](#7-性能优化)
8. [实现细节](#8-实现细节)
9. [安全考虑](#9-安全考虑)

---

## 1. 概述

### 1.1 设计目标

航图加密方案旨在：

- 🔒 **保护航图数据安全**：防止未授权访问和分发
- ⚡ **高性能访问**：按需读取，不影响用户体验
- 📦 **便于分发更新**：单文件打包，易于 OTA 更新
- 💾 **节省存储空间**：压缩 + 加密，减少磁盘占用
- 🎯 **灵活缓存管理**：可选的文件级缓存机制

### 1.2 核心概念

- **AIPKG 包**：自定义格式的加密数据包，包含完整的 EAIP 版本数据
- **索引驱动**：通过内嵌索引实现按需文件读取
- **三层密钥**：用户密码 → Master Key → File Key 的密钥派生体系
- **智能缓存**：可选的文件级缓存，加速热门航图访问

---

## 2. 加密架构

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                    用户层                                    │
│  用户输入密码 → 查看航图 → 缓存管理                          │
└──────────────────┬──────────────────────────────────────────┘
                   │
┌──────────────────▼──────────────────────────────────────────┐
│                  应用层                                      │
│  - AIPKG Manager  (包管理)                                  │
│  - Chart Scanner  (航图扫描)                                │
│  - Cache Manager  (缓存管理)                                │
└──────────────────┬──────────────────────────────────────────┘
                   │
┌──────────────────▼──────────────────────────────────────────┐
│                  加密层                                      │
│  - 密钥派生 (PBKDF2-HMAC-SHA256)                           │
│  - 文件加密 (AES-256-GCM)                                   │
│  - 索引加密 (AES-256-GCM)                                   │
└──────────────────┬──────────────────────────────────────────┘
                   │
┌──────────────────▼──────────────────────────────────────────┐
│                  存储层                                      │
│  - packages/xxx.aipkg     (加密的数据包)                    │
│  - cache/xxx.aip          (可选的加密缓存)                  │
│  - data/eaip_viewer.db    (索引数据库)                      │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 密钥层次结构

```
用户密码 (User Password)
    ↓
    ↓ PBKDF2-HMAC-SHA256
    ↓ Iterations: 100,000
    ↓ Salt: 32 bytes (随机)
    ↓
Master Key (256 bits)
    ↓ 存储在内存中，不落盘
    ↓
    ├─→ 解密 Index Block
    │   └─→ 获取所有文件的元数据和 IV
    │
    └─→ 解密单个 File Key (未来扩展)
        └─→ File Key 解密具体的 PDF 文件
```

---

## 3. AIPKG 文件格式

### 3.1 文件结构

```
┌──────────────────────────────────────────────────────────┐
│  Header (512 bytes)                                      │ ← 文件头（明文）
├──────────────────────────────────────────────────────────┤
│  Encrypted Index Block (可变长度)                        │ ← 加密的索引（JSON）
├──────────────────────────────────────────────────────────┤
│  Data Block 1 (加密 + 压缩的 PDF)                        │ ← 航图文件 1
├──────────────────────────────────────────────────────────┤
│  Data Block 2 (加密 + 压缩的 PDF)                        │ ← 航图文件 2
├──────────────────────────────────────────────────────────┤
│  Data Block 3 (加密 + 压缩的 PDF)                        │ ← 航图文件 3
├──────────────────────────────────────────────────────────┤
│  ...                                                     │
└──────────────────────────────────────────────────────────┘
```

### 3.2 Header 格式 (512 bytes)

| Offset | Size | Field Name          | Type     | Description                          |
|--------|------|---------------------|----------|--------------------------------------|
| 0      | 4    | magic               | char[4]  | "AIPK" (0x4149504B) 魔数            |
| 4      | 2    | version_major       | uint16   | 主版本号 (当前: 1)                   |
| 6      | 2    | version_minor       | uint16   | 次版本号 (当前: 0)                   |
| 8      | 8    | index_offset        | uint64   | 索引块起始位置（字节偏移）            |
| 16     | 8    | index_length        | uint64   | 索引块长度（加密后的字节数）          |
| 24     | 32   | index_iv            | byte[32] | 索引块加密的初始化向量 (IV)           |
| 56     | 32   | master_salt         | byte[32] | 主密钥派生的盐值                     |
| 88     | 64   | file_hash           | byte[64] | 整个文件的 SHA256 哈希（校验用）      |
| 152    | 8    | created_timestamp   | int64    | 创建时间戳 (Unix timestamp)          |
| 160    | 8    | total_files         | uint64   | 总文件数                             |
| 168    | 8    | total_data_size     | uint64   | 总数据大小（未压缩，字节）            |
| 176    | 4    | compression_algo    | uint32   | 压缩算法 (0=None, 1=gzip, 2=zstd)   |
| 180    | 4    | encryption_algo     | uint32   | 加密算法 (1=AES-256-GCM)            |
| 184    | 128  | metadata            | char[128]| 版本信息（JSON 字符串）              |
| 312    | 200  | reserved            | byte[200]| 保留字段（未来扩展）                 |

**Header 示例（十六进制）：**

```
0000  41 49 50 4B 00 01 00 00  00 00 00 00 00 00 02 00  |AIPK............|
      ^Magic  ^Ver  ^Index Offset................
```

### 3.3 Index Block 格式

Index Block 是一个加密的 JSON 数据，包含所有文件的元数据。

#### 加密前的 JSON 结构：

```json
{
  "package_info": {
    "eaip_version": "EAIP2025-07.V1.4",
    "effective_date": "2025-07-01T00:00:00Z",
    "expiry_date": "2025-08-01T00:00:00Z",
    "created_at": "2025-10-01T12:00:00Z",
    "airports_count": 156,
    "charts_count": 3421,
    "total_size": 524288000,
    "compression_ratio": 0.65
  },
  "airports": [
    {
      "icao": "ZBAA",
      "name_cn": "北京首都国际机场",
      "name_en": "Beijing Capital International Airport",
      "latitude": 40.0799,
      "longitude": 116.6031,
      "elevation": 116,
      "file_count": 45
    },
    {
      "icao": "ZBAD",
      "name_cn": "北京南苑机场",
      "name_en": "Beijing Nanyuan Airport",
      "file_count": 28
    }
  ],
  "categories": [
    {"code": "ADC", "name_cn": "机场图", "name_en": "Aerodrome Chart"},
    {"code": "SID", "name_cn": "标准仪表离场", "name_en": "Standard Instrument Departure"},
    {"code": "STAR", "name_cn": "标准终端进场", "name_en": "Standard Terminal Arrival Route"},
    {"code": "IAC", "name_cn": "仪表进近图", "name_en": "Instrument Approach Chart"}
  ],
  "files": [
    {
      "id": "zbaa_sid_7a01",
      "airport": "ZBAA",
      "category": "SID",
      "file_name": "ZBAA-7A01-SID RNAV RWY01-36L-36R(IDKEX).pdf",
      "title": "SID RNAV RWY01-36L-36R(IDKEX)",
      "chart_number": "ZBAA-7A01",
      "runway": "01-36L-36R",
      "procedure": "IDKEX",

      "offset": 4096,
      "compressed_size": 102400,
      "original_size": 204800,
      "compression_ratio": 0.5,

      "iv": "YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=",
      "file_hash": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",

      "page_count": 1,
      "created_at": "2025-07-01T00:00:00Z"
    },
    {
      "id": "zbaa_star_9a",
      "airport": "ZBAA",
      "category": "STAR",
      "file_name": "ZBAA-9A-STAR RNAV RWY01-36L-36R(GUVBA-OSUBA).pdf",
      "title": "STAR RNAV RWY01-36L-36R(GUVBA-OSUBA)",
      "offset": 106496,
      "compressed_size": 153600,
      "original_size": 307200,
      "iv": "MTIzNDU2Nzg5MGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3",
      "file_hash": "d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592",
      "page_count": 2
    }
  ]
}
```

#### Index Block 加密过程：

```python
# 1. 将 JSON 转换为字节
index_json = json.dumps(index_data, ensure_ascii=False).encode('utf-8')

# 2. 使用 Master Key 和 index_iv 加密
encrypted_index = AES_GCM_encrypt(
    key=master_key,
    iv=index_iv,
    plaintext=index_json,
    aad=b"AIPK_INDEX_V1"  # Additional Authenticated Data
)

# 3. 写入 .aipkg 文件
file.seek(index_offset)
file.write(encrypted_index)
```

### 3.4 Data Block 格式

每个 Data Block 是一个独立的加密文件：

```
┌──────────────────────────────────┐
│  原始 PDF (204800 bytes)          │
│                                   │
│  ↓ gzip 压缩                      │
│                                   │
│  压缩后 (102400 bytes)            │
│                                   │
│  ↓ AES-256-GCM 加密               │
│    - Key: Master Key              │
│    - IV: 来自 Index 的 iv 字段    │
│    - AAD: file_id                 │
│                                   │
│  加密后 (102416 bytes)            │
│  (包含 16 bytes GCM tag)          │
└──────────────────────────────────┘
```

**加密过程：**

```python
def encrypt_file(pdf_content: bytes, file_id: str, master_key: bytes, iv: bytes) -> bytes:
    """
    加密单个 PDF 文件

    Args:
        pdf_content: 原始 PDF 内容
        file_id: 文件 ID（用作 AAD）
        master_key: 主密钥（256 bits）
        iv: 初始化向量（256 bits）

    Returns:
        加密后的数据（包含 GCM tag）
    """
    # 1. 压缩
    compressed = gzip.compress(pdf_content, compresslevel=6)

    # 2. 加密
    cipher = AES.new(master_key, AES.MODE_GCM, nonce=iv)
    cipher.update(file_id.encode('utf-8'))  # AAD
    encrypted, tag = cipher.encrypt_and_digest(compressed)

    # 3. 返回 encrypted + tag
    return encrypted + tag
```

---

## 4. 密钥管理

### 4.1 Master Key 派生

使用 PBKDF2-HMAC-SHA256 从用户密码派生 Master Key：

```python
import hashlib
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.backends import default_backend

def derive_master_key(password: str, salt: bytes, iterations: int = 100000) -> bytes:
    """
    从用户密码派生 Master Key

    Args:
        password: 用户输入的密码
        salt: 盐值（32 bytes，存储在 Header 中）
        iterations: PBKDF2 迭代次数（默认 100,000）

    Returns:
        32 字节的 Master Key
    """
    kdf = PBKDF2HMAC(
        algorithm=hashlib.sha256(),
        length=32,              # 256 bits
        salt=salt,
        iterations=iterations,
        backend=default_backend()
    )
    return kdf.derive(password.encode('utf-8'))
```

**参数选择理由：**

- **PBKDF2-HMAC-SHA256**：成熟稳定的算法，广泛支持
- **100,000 迭代**：平衡安全性和性能（约 100-200ms）
- **32 字节盐值**：足够的随机性，防止彩虹表攻击

### 4.2 密钥存储

| 密钥类型 | 存储位置 | 生命周期 | 保护方式 |
|---------|---------|---------|---------|
| **用户密码** | 用户输入 | 会话级 | 不存储 |
| **Master Salt** | .aipkg Header | 永久 | 明文（公开） |
| **Master Key** | 内存 | 会话级 | 只在内存中，不落盘 |
| **Index IV** | .aipkg Header | 永久 | 明文（公开） |
| **File IV** | Index Block | 永久 | 加密存储（在 Index 中） |

**安全原则：**

1. ✅ **用户密码不存储**：每次使用时重新输入或从系统密钥链读取
2. ✅ **Master Key 只在内存**：进程结束时自动销毁
3. ✅ **Salt 和 IV 可以公开**：安全性完全依赖密钥
4. ✅ **不使用相同的 IV**：每个文件独立的 IV

### 4.3 IV 生成

```python
import os

def generate_iv() -> bytes:
    """
    生成安全的随机 IV

    Returns:
        32 字节的随机 IV（用于 AES-256-GCM）
    """
    return os.urandom(32)  # 使用操作系统的 CSPRNG
```

---

## 5. 工作流程

### 5.1 打包流程（服务器端）

```
┌─────────────────────────────────────────────────────────────┐
│  输入：原始航图目录 (Data/EAIP2025-07.V1.4/Terminal)         │
└──────────────────┬──────────────────────────────────────────┘
                   │
                   ▼
         ┌─────────────────────┐
         │ 1. 扫描文件树        │
         │    - 遍历所有 PDF    │
         │    - 提取元数据      │
         └──────┬──────────────┘
                │
                ▼
         ┌─────────────────────┐
         │ 2. 生成密钥材料      │
         │    - Master Salt     │
         │    - Index IV        │
         │    - 各文件 IV       │
         └──────┬──────────────┘
                │
                ▼
         ┌─────────────────────┐
         │ 3. 压缩并加密文件    │
         │    - gzip 压缩       │
         │    - AES-GCM 加密    │
         └──────┬──────────────┘
                │
                ▼
         ┌─────────────────────┐
         │ 4. 构建索引          │
         │    - JSON 格式       │
         │    - 包含所有元数据  │
         └──────┬──────────────┘
                │
                ▼
         ┌─────────────────────┐
         │ 5. 加密索引          │
         │    - AES-GCM         │
         └──────┬──────────────┘
                │
                ▼
         ┌─────────────────────┐
         │ 6. 写入 .aipkg       │
         │    - Header          │
         │    - Encrypted Index │
         │    - Data Blocks     │
         └──────┬──────────────┘
                │
                ▼
┌─────────────────────────────────────────────────────────────┐
│  输出：eaip-2507.aipkg (500MB)                               │
└─────────────────────────────────────────────────────────────┘
```

**代码示例：**

```python
from src.core.aipkg_builder import AIPKGBuilder

builder = AIPKGBuilder()
result = builder.create_package(
    source_dir="Data/EAIP2025-07.V1.4/Terminal",
    output_path="packages/eaip-2507.aipkg",
    password="distribution_password",
    compression="gzip",
    compression_level=6
)

print(f"打包完成:")
print(f"  - 文件总数: {result['total_files']}")
print(f"  - 原始大小: {result['original_size'] / 1024 / 1024:.2f} MB")
print(f"  - 压缩大小: {result['compressed_size'] / 1024 / 1024:.2f} MB")
print(f"  - 压缩率: {result['compression_ratio'] * 100:.1f}%")
```

### 5.2 首次加载流程（客户端）

```
┌─────────────────────────────────────────────────────────────┐
│  输入：eaip-2507.aipkg + 用户密码                            │
└──────────────────┬──────────────────────────────────────────┘
                   │
                   ▼
         ┌─────────────────────┐
         │ 1. 读取 Header       │
         │    - 验证 Magic      │
         │    - 读取版本信息    │
         │    - 获取 Salt       │
         └──────┬──────────────┘
                │
                ▼
         ┌─────────────────────┐
         │ 2. 派生 Master Key   │
         │    - PBKDF2          │
         │    - 存储在内存      │
         └──────┬──────────────┘
                │
                ▼
         ┌─────────────────────┐
         │ 3. 读取 Index Block  │
         │    - seek(offset)    │
         │    - read(length)    │
         └──────┬──────────────┘
                │
                ▼
         ┌─────────────────────┐
         │ 4. 解密 Index        │
         │    - AES-GCM 解密    │
         │    - 验证 GCM tag    │
         └──────┬──────────────┘
                │
                ▼
         ┌─────────────────────┐
         │ 5. 解析 JSON         │
         │    - 获取文件列表    │
         │    - 获取元数据      │
         └──────┬──────────────┘
                │
                ▼
         ┌─────────────────────┐
         │ 6. 导入数据库        │
         │    - 版本信息        │
         │    - 机场信息        │
         │    - 航图索引        │
         └──────┬──────────────┘
                │
                ▼
┌─────────────────────────────────────────────────────────────┐
│  完成：数据库中有完整索引，可以查询航图                      │
└─────────────────────────────────────────────────────────────┘
```

**代码示例：**

```python
from src.core.aipkg_manager import AIPKGManager

manager = AIPKGManager()

# 加载包
package = manager.load_package(
    package_path="packages/eaip-2507.aipkg",
    password="user_password"
)

# 导入索引到数据库
package.import_to_database()

print(f"加载成功:")
print(f"  - EAIP 版本: {package.info['eaip_version']}")
print(f"  - 机场数量: {package.info['airports_count']}")
print(f"  - 航图数量: {package.info['charts_count']}")
```

### 5.3 查看航图流程

```
┌─────────────────────────────────────────────────────────────┐
│  用户操作：点击查看某个航图                                  │
└──────────────────┬──────────────────────────────────────────┘
                   │
                   ▼
         ┌─────────────────────┐
         │ 1. 查询数据库        │
         │    - 获取文件元数据  │
         │    - offset, size    │
         │    - iv, hash        │
         └──────┬──────────────┘
                │
                ▼
         ┌─────────────────────┐
      ┌─→│ 2. 检查缓存          │
      │  │    - 是否有 .aip？   │
      │  └──────┬──────────────┘
      │         │
      │         ├─→ 有缓存 ─┐
      │         │           │
      │         └─→ 无缓存  │
      │                     │
      │                     ▼
      │         ┌─────────────────────┐
      │         │ 3a. 从包中提取       │
      │         │     - open(.aipkg)   │
      │         │     - seek(offset)   │
      │         │     - read(size)     │
      │         └──────┬──────────────┘
      │                │
      │                ▼
      │         ┌─────────────────────┐
      │         │ 4. 解密数据          │
      │         │    - AES-GCM         │
      │         │    - 验证 tag        │
      │         └──────┬──────────────┘
      │                │
      │                ▼
      │         ┌─────────────────────┐
      │         │ 5. 解压数据          │
      │         │    - gzip decompress │
      │         └──────┬──────────────┘
      │                │
      │                ▼
      │         ┌─────────────────────┐
      │         │ 6. 验证完整性        │
      │         │    - SHA256 hash     │
      │         └──────┬──────────────┘
      │                │
      │                ▼
      │         ┌─────────────────────┐
      └─────────│ 7. 可选：缓存文件    │
                │    - 写入 .aip       │
                │    - 更新数据库      │
                └──────┬──────────────┘
                       │
                       ▼
         ┌─────────────────────┐
         │ 8. 显示 PDF          │
         │    - BytesIO         │
         │    - PDF Viewer      │
         └─────────────────────┘
```

**代码示例：**

```python
from src.core.aipkg_manager import AIPKGManager

manager = AIPKGManager()

# 用户选择航图
chart_id = 123

# 获取 PDF 数据
pdf_data = manager.get_chart(
    chart_id=chart_id,
    password="user_password",
    use_cache=True,        # 优先使用缓存
    save_to_cache=True     # 如果没有缓存，则保存
)

# pdf_data 是 BytesIO 对象，可以直接传给 PDF 查看器
pdf_viewer.load(pdf_data)
```

---

## 6. 安全特性

### 6.1 加密算法

| 组件 | 算法 | 密钥长度 | 说明 |
|------|------|----------|------|
| **密钥派生** | PBKDF2-HMAC-SHA256 | 256 bits | 100,000 迭代 |
| **文件加密** | AES-256-GCM | 256 bits | 认证加密 |
| **索引加密** | AES-256-GCM | 256 bits | 认证加密 |
| **哈希校验** | SHA-256 | 256 bits | 完整性验证 |

### 6.2 防篡改机制

#### 6.2.1 三层验证

1. **文件级验证**
   - Header 中存储整个 .aipkg 的 SHA256
   - 加载时验证文件完整性

2. **索引级验证**
   - AES-GCM 提供认证加密
   - 任何修改会导致 GCM tag 验证失败

3. **数据块级验证**
   - 每个文件的原始 SHA256 存储在 Index 中
   - 解密后验证内容是否被篡改

#### 6.2.2 验证流程

```python
def verify_package(package_path: str) -> bool:
    """验证 .aipkg 包的完整性"""

    # 1. 读取 Header
    with open(package_path, 'rb') as f:
        header = f.read(512)
        stored_hash = header[88:152]  # file_hash

        # 2. 计算实际哈希
        f.seek(512)  # 跳过 Header
        actual_hash = hashlib.sha256()
        while chunk := f.read(8192):
            actual_hash.update(chunk)

        # 3. 比对哈希
        return actual_hash.digest() == stored_hash
```

### 6.3 密钥安全

#### 6.3.1 Master Key 管理

```python
class SecureKeyManager:
    """安全的密钥管理器"""

    def __init__(self):
        self._master_key = None  # 只在内存中

    def derive_key(self, password: str, salt: bytes) -> None:
        """派生并存储 Master Key"""
        self._master_key = derive_master_key(password, salt)

    def get_key(self) -> bytes:
        """获取 Master Key"""
        if self._master_key is None:
            raise ValueError("Master Key 未初始化")
        return self._master_key

    def clear(self) -> None:
        """清除 Master Key"""
        if self._master_key is not None:
            # 覆写内存（防止内存残留）
            self._master_key = bytes(len(self._master_key))
            self._master_key = None

    def __del__(self):
        """析构时自动清除"""
        self.clear()
```

#### 6.3.2 用户密码存储（可选）

如果用户选择"记住密码"，使用系统密钥链：

- **Windows**: Windows Credential Manager
- **macOS**: Keychain
- **Linux**: Secret Service API (libsecret)

```python
import keyring

# 保存密码
keyring.set_password("EAIP_Viewer", "master_password", user_password)

# 读取密码
password = keyring.get_password("EAIP_Viewer", "master_password")
```

### 6.4 安全威胁分析

| 威胁 | 防护措施 | 残余风险 |
|------|----------|----------|
| **暴力破解** | PBKDF2 100k 迭代 + 强密码策略 | 低 |
| **字典攻击** | 随机 Salt，防止预计算 | 极低 |
| **中间人攻击** | HTTPS 下载 + 文件哈希验证 | 极低 |
| **内存转储** | Master Key 存储时间最小化 | 低 |
| **文件篡改** | GCM 认证加密 + SHA256 | 极低 |
| **重放攻击** | 每个文件独立 IV | 无 |
| **侧信道攻击** | 使用标准库，假设无缺陷 | 低 |

---

## 7. 性能优化

### 7.1 关键指标

| 操作 | 目标时间 | 实测时间 | 优化措施 |
|------|----------|----------|----------|
| **首次加载** | < 2s | ~0.5s | 只读 Index，不解密文件 |
| **后续启动** | < 1s | ~0.3s | 数据库索引缓存 |
| **查看航图（无缓存）** | < 1s | ~0.4s | 流式解密，gzip 解压 |
| **查看航图（有缓存）** | < 0.3s | ~0.1s | 直接读缓存 |
| **切换航图** | < 0.5s | ~0.2s | 预加载相邻航图 |

### 7.2 缓存策略

#### 7.2.1 LRU 缓存

```python
from functools import lru_cache

class ChartCache:
    """航图缓存管理器"""

    def __init__(self, max_size_mb: int = 100):
        self.max_size = max_size_mb * 1024 * 1024
        self.current_size = 0
        self.cache = {}  # {chart_id: (data, size, timestamp)}

    def put(self, chart_id: int, data: bytes) -> None:
        """添加到缓存"""
        size = len(data)

        # 如果超过大小限制，移除最旧的
        while self.current_size + size > self.max_size:
            self._evict_oldest()

        self.cache[chart_id] = (data, size, time.time())
        self.current_size += size

    def get(self, chart_id: int) -> Optional[bytes]:
        """从缓存获取"""
        if chart_id in self.cache:
            data, size, _ = self.cache[chart_id]
            # 更新时间戳（LRU）
            self.cache[chart_id] = (data, size, time.time())
            return data
        return None
```

#### 7.2.2 预加载策略

```python
def preload_adjacent_charts(current_chart_id: int) -> None:
    """
    预加载相邻的航图（后台线程）

    策略：
    1. 同类型的下一个航图（如 SID-7A01 → SID-7A02）
    2. 同机场的其他常用类型（如 SID → STAR → IAC）
    """
    # 获取相邻航图 ID
    adjacent_ids = get_adjacent_chart_ids(current_chart_id)

    # 后台预加载
    for chart_id in adjacent_ids[:3]:  # 最多预加载 3 个
        threading.Thread(
            target=manager.get_chart,
            args=(chart_id,),
            kwargs={'save_to_cache': True}
        ).start()
```

### 7.3 内存优化

#### 7.3.1 流式处理

```python
def decrypt_large_file(encrypted_data: bytes, key: bytes, iv: bytes) -> BytesIO:
    """
    流式解密大文件

    优点：
    - 不需要一次性加载到内存
    - 边解密边解压边返回
    """
    cipher = AES.new(key, AES.MODE_GCM, nonce=iv)

    # 创建解压器
    decompressor = zlib.decompressobj(wbits=zlib.MAX_WBITS | 16)

    output = BytesIO()
    chunk_size = 64 * 1024  # 64KB chunks

    for i in range(0, len(encrypted_data), chunk_size):
        chunk = encrypted_data[i:i + chunk_size]
        decrypted = cipher.decrypt(chunk)
        decompressed = decompressor.decompress(decrypted)
        output.write(decompressed)

    output.seek(0)
    return output
```

#### 7.3.2 弱引用缓存

```python
import weakref

class WeakChartCache:
    """使用弱引用的缓存，自动释放不用的对象"""

    def __init__(self):
        self.cache = weakref.WeakValueDictionary()

    def get(self, chart_id: int):
        return self.cache.get(chart_id)

    def put(self, chart_id: int, data):
        self.cache[chart_id] = data
```

### 7.4 磁盘 I/O 优化

#### 7.4.1 mmap 映射

```python
import mmap

class FastAIPKGReader:
    """使用内存映射读取 .aipkg"""

    def __init__(self, package_path: str):
        self.file = open(package_path, 'rb')
        self.mmap = mmap.mmap(
            self.file.fileno(),
            0,
            access=mmap.ACCESS_READ
        )

    def read_block(self, offset: int, length: int) -> bytes:
        """快速读取数据块"""
        return self.mmap[offset:offset + length]

    def close(self):
        self.mmap.close()
        self.file.close()
```

---

## 8. 实现细节

### 8.1 核心类设计

```python
# src/core/aipkg_format.py
class AIPKGHeader:
    """AIPKG 文件头"""
    SIZE = 512
    MAGIC = b'AIPK'

    def __init__(self):
        self.version_major = 1
        self.version_minor = 0
        self.index_offset = 0
        self.index_length = 0
        self.index_iv = None
        self.master_salt = None
        # ...

    @classmethod
    def from_bytes(cls, data: bytes) -> 'AIPKGHeader':
        """从字节解析"""
        pass

    def to_bytes(self) -> bytes:
        """转换为字节"""
        pass

# src/core/aipkg_builder.py
class AIPKGBuilder:
    """AIPKG 包构建器"""

    def create_package(
        self,
        source_dir: str,
        output_path: str,
        password: str,
        compression: str = 'gzip',
        compression_level: int = 6
    ) -> dict:
        """创建 AIPKG 包"""
        pass

# src/core/aipkg_manager.py
class AIPKGManager:
    """AIPKG 包管理器"""

    def load_package(self, package_path: str, password: str) -> 'AIPKGPackage':
        """加载包"""
        pass

    def get_chart(
        self,
        chart_id: int,
        password: str,
        use_cache: bool = True,
        save_to_cache: bool = False
    ) -> BytesIO:
        """获取航图数据"""
        pass

# src/core/aipkg_reader.py
class AIPKGReader:
    """AIPKG 文件读取器"""

    def __init__(self, package_path: str):
        self.path = package_path
        self.header = None
        self.index = None

    def read_header(self) -> AIPKGHeader:
        """读取文件头"""
        pass

    def read_index(self, master_key: bytes) -> dict:
        """读取并解密索引"""
        pass

    def extract_file(self, file_info: dict, master_key: bytes) -> bytes:
        """提取单个文件"""
        pass
```

### 8.2 数据库模型扩展

```python
# src/models/chart.py

class ChartPackage(Base, TimestampMixin):
    """AIPKG 包信息"""

    __tablename__ = "chart_packages"

    id = Column(Integer, primary_key=True)
    eaip_version = Column(String(100), nullable=False)
    file_path = Column(String(1000), nullable=False)
    file_hash = Column(String(64), nullable=False)

    # 包信息
    total_files = Column(Integer, nullable=False)
    total_size = Column(BigInteger, nullable=False)
    compression_algo = Column(String(20), nullable=False)

    # 状态
    is_active = Column(Boolean, default=True)
    is_verified = Column(Boolean, default=False)

    # 关系
    charts = relationship("Chart", back_populates="package")


class Chart(Base, TimestampMixin):
    """航图文件（扩展）"""

    __tablename__ = "charts"

    id = Column(Integer, primary_key=True)
    package_id = Column(Integer, ForeignKey("chart_packages.id"), nullable=False)

    # 文件信息
    file_id = Column(String(100), nullable=False, unique=True)
    file_name = Column(String(500), nullable=False)

    # 在包中的位置
    data_offset = Column(BigInteger, nullable=False)
    compressed_size = Column(Integer, nullable=False)
    original_size = Column(Integer, nullable=False)

    # 加密信息
    encryption_iv = Column(String(64), nullable=False)
    file_hash = Column(String(64), nullable=False)

    # 缓存信息
    is_cached = Column(Boolean, default=False)
    cached_path = Column(String(1000), nullable=True)
    cache_hits = Column(Integer, default=0)
    last_accessed = Column(DateTime, nullable=True)

    # 关系
    package = relationship("ChartPackage", back_populates="charts")
```

---

## 9. 安全考虑

### 9.1 密码策略

建议的密码要求：

- ✅ 最小长度：12 字符
- ✅ 包含大小写字母、数字、特殊字符
- ✅ 不包含常见弱密码
- ✅ 定期更换（可选）

```python
import re

def validate_password(password: str) -> tuple[bool, str]:
    """
    验证密码强度

    Returns:
        (是否有效, 错误信息)
    """
    if len(password) < 12:
        return False, "密码长度至少 12 个字符"

    if not re.search(r'[a-z]', password):
        return False, "密码必须包含小写字母"

    if not re.search(r'[A-Z]', password):
        return False, "密码必须包含大写字母"

    if not re.search(r'\d', password):
        return False, "密码必须包含数字"

    if not re.search(r'[!@#$%^&*(),.?":{}|<>]', password):
        return False, "密码必须包含特殊字符"

    # 检查常见弱密码
    weak_passwords = ['password123', 'qwerty123456', ...]
    if password.lower() in weak_passwords:
        return False, "密码过于简单"

    return True, ""
```

### 9.2 密钥轮换

支持定期更换加密密钥：

```python
def rotate_keys(
    old_password: str,
    new_password: str,
    package_path: str
) -> None:
    """
    密钥轮换（重新加密整个包）

    步骤：
    1. 用旧密码解密所有文件
    2. 生成新的 Salt 和 IV
    3. 用新密码重新加密
    4. 写入新的 .aipkg
    """
    # 1. 加载旧包
    old_manager = AIPKGManager()
    old_package = old_manager.load_package(package_path, old_password)

    # 2. 提取所有文件（解密）
    decrypted_files = []
    for file_info in old_package.index['files']:
        data = old_manager.extract_file(file_info['id'], old_password)
        decrypted_files.append((file_info, data))

    # 3. 用新密码重新打包
    builder = AIPKGBuilder()
    builder.create_from_memory(
        files=decrypted_files,
        output_path=package_path + '.new',
        password=new_password
    )

    # 4. 替换旧文件
    os.replace(package_path + '.new', package_path)
```

### 9.3 审计日志

记录所有加密操作：

```python
class SecurityAuditLogger:
    """安全审计日志"""

    def log_package_load(self, package_path: str, success: bool):
        """记录包加载"""
        logger.security(
            f"包加载: {package_path}, "
            f"结果: {'成功' if success else '失败'}, "
            f"时间: {datetime.now()}"
        )

    def log_chart_access(self, chart_id: int, user_id: int):
        """记录航图访问"""
        logger.security(
            f"航图访问: ID={chart_id}, "
            f"用户: {user_id}, "
            f"时间: {datetime.now()}"
        )

    def log_decryption_failure(self, reason: str):
        """记录解密失败"""
        logger.warning(
            f"解密失败: {reason}, "
            f"时间: {datetime.now()}"
        )
```

### 9.4 应急响应

如果密钥泄露，应急处理：

1. **立即通知用户**
2. **强制密钥轮换**
3. **撤销旧版本包**
4. **推送新的加密包**

---

## 附录

### A. 加密算法选择理由

| 算法 | 选择理由 |
|------|----------|
| **AES-256-GCM** | 认证加密，防篡改；硬件加速；标准成熟 |
| **PBKDF2** | 标准成熟；广泛支持；可调迭代次数 |
| **SHA-256** | 标准哈希算法；无已知碰撞 |

### B. 依赖库

```python
# requirements.txt
cryptography>=41.0.0      # 加密库
PyNaCl>=1.5.0            # 额外的加密工具（可选）
```

### C. 参考资料

- [NIST SP 800-38D: GCM Mode](https://csrc.nist.gov/publications/detail/sp/800-38d/final)
- [NIST SP 800-132: PBKDF2](https://csrc.nist.gov/publications/detail/sp/800-132/final)
- [RFC 5652: Cryptographic Message Syntax](https://tools.ietf.org/html/rfc5652)

---

## 文档变更历史

| 版本 | 日期 | 作者 | 变更说明 |
|------|------|------|----------|
| v1.0 | 2025-10-01 | Claude | 初始版本 |

---

**文档结束**
